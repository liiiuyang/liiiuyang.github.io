{"meta":{"title":"Sk8erBoi的笔记","subtitle":"","description":"","author":"Sk8erBoi","url":"https://www.leavel.cn"},"pages":[{"title":"分类","date":"2020-04-06T04:44:34.000Z","updated":"2021-04-24T08:24:40.907Z","comments":false,"path":"categories/index.html","permalink":"https://www.leavel.cn/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-04-25T13:33:19.505Z","updated":"2021-04-25T13:33:19.505Z","comments":true,"path":"about/index.html","permalink":"https://www.leavel.cn/about/index.html","excerpt":"","text":"自1997 至今仍一事无成"},{"title":"Contact","date":"2020-04-27T05:16:03.000Z","updated":"2021-04-25T13:34:55.099Z","comments":true,"path":"link/index.html","permalink":"https://www.leavel.cn/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-04T05:15:29.000Z","updated":"2021-04-24T08:29:42.416Z","comments":false,"path":"tags/index.html","permalink":"https://www.leavel.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux压测环境搭建（Jmeter）及压测","slug":"13_Linux_Jmeter","date":"2022-05-02T13:18:01.000Z","updated":"2022-05-02T13:25:48.653Z","comments":true,"path":"article/20220502.html","link":"","permalink":"https://www.leavel.cn/article/20220502.html","excerpt":"环境：Centos7Jmeter: Apache JMeter - Download Apache JMeterJDK:在线安装 yum install jdk","text":"环境：Centos7Jmeter: Apache JMeter - Download Apache JMeterJDK:在线安装 yum install jdk 一.安装JDK1.yum search java|grep jdk #下载jdk2.yum install -y java-1.8.0-openjdk*3.java -version javac #查看是否安装成功 [root@localhost ]# which java /usr/bin/java [root@localhost ]# ls -lr /usr/bin/java lrwxrwxrwx. 1 root root 22 6月 29 10:30 /usr/bin/java -&gt; /etc/alternatives/java [root@localhost ]# ls -lr /etc/alternatives/java lrwxrwxrwx. 1 root root 73 6月 29 10:30 /etc/alternatives/java -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.292.b10-1.el7_9.x86_64/jre/bin/java二.配置环境变量① vi /etc/profile #打开环境编辑的文件 ② 在文件最后加上这四行 export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.322.b06-1.el7_9.x86_64 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.322.b06-1.el7_9.x86_64/jre/bin/java ③ :wq //保存并退出文件 ④ source /etc/profile //使文件生效 ⑤ echo $JAVA_HOME //验证是否编辑成功 三.上传Jmeter压缩包，解压1.unzip file.zip #解压缩file.zip文件 四.压测1.#运行jmeter脚本 /home/apache-jmeter-5.4.3/bin/jmeter.sh -n -t /jmx/jmxscript/historicTaskList.jmx -l /jmx/jmxscript/report/historicTaskList2000.jtl -JthreadCount=2000 -JrampUp=2 -JkeepTime=300 2.#将测试结果.jtl文件转换为html /home/apache-jmeter-5.4.3/bin/jmeter.sh -g /jmx/jmxscript/report/historicTaskList2000.jtl -e -o /jmx/jmxscript/report/historicTaskList2000 3.#将文件夹压缩 把xx路径下的historicTaskList2000文件夹压缩后放到xx路径 zip -q -r /jmx/jmxscript/report/result/historicTaskList2000.zip /jmx/jmxscript/report/historicTaskList2000/","categories":[],"tags":[{"name":"jmeter","slug":"jmeter","permalink":"https://www.leavel.cn/tags/jmeter/"},{"name":"linux","slug":"linux","permalink":"https://www.leavel.cn/tags/linux/"}],"keywords":[]},{"title":"软件测试面试题目","slug":"12_TestMeet","date":"2022-03-15T10:51:32.000Z","updated":"2022-03-15T11:40:12.751Z","comments":true,"path":"article/20220315.html","link":"","permalink":"https://www.leavel.cn/article/20220315.html","excerpt":"简单记一下：测试流程有哪些：1.需求评审2.测试计划3.编写测试用例","text":"简单记一下：测试流程有哪些：1.需求评审2.测试计划3.编写测试用例 4.测试用例评审5.系统测试6.生成测试报告 测试用例的七个方法 1.基于需求的设计方法依据看客户需求设计测试用例2.等价类依据需求将输入划分为若干等价类，从等价类中选定一个测试用例，如果该测试用例通过，则表明整个等价类通过测试。3.边界值边界值法是对输入数据的边界测试，是一种黑盒测试方法；一般来说边界值法是对等价类划分后的补充4.因果图因果图是一种简化的逻辑图，能够表示输入条件和输出结果之间的关系。5.错误猜测法错误猜测法是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例。列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。6.场景设计法目前的大多数软件的事件触发来控制流程的，我们可通过想象事件触发时的情景形成流程，依据同一事件不同的触发顺序和结果形成事件流，再依据事件流设计测试用例。一般场景设计法与需求设计法结合使用，能够将多个孤立的功能联系在一起7.正交排列 自动化测试八大元素定位find_element_by_name()find_element_by_id()find_element_by_class_name()find_element_by_tag_name()find_element_by_link_text()find_element_by_partial_link_text()find_element_by_xpath()find_element_by_css_selector() 模拟键盘操作定位selenium模拟键盘操作大全 - 多测师张sir - 博客园 (cnblogs.com) 动态元素如何定位xpath定位①//input[@name=’account’] ②//*[@name=’accout’] ③ 定位下拉框 //li//span[text()=’男’] ④ (//li//span[text()=’在职’])[1] 选第一个 ⑤//li//span[text()=’在职’]/a[last()] 选最后一个 ⑥//li//span[text()=’在职’]/a[last()-1] 选倒数第二个 常见的异常解决手段1.元素没有找到（定位错误，没有添加等待，iframe未切换）2.元素无法正常交互（页面是否最大化，是否需要滚动条，是否需要悬停）3.超时（显示等待超时因为元素有误，窗体最大化超时）4.创建session失败（检查浏览器版本与driver是否匹配） http协议状态码：1xx 请求成功，继续处理2xx 请求发送成功3xx 重定向4xx 客户端错误5xx 服务端错误","categories":[],"tags":[{"name":"软件测试","slug":"软件测试","permalink":"https://www.leavel.cn/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"}],"keywords":[]},{"title":"Python + Selenium自动化测试练习","slug":"11_AutoTest01","date":"2022-02-20T11:28:14.000Z","updated":"2022-02-20T12:47:53.854Z","comments":true,"path":"article/20220220.html","link":"","permalink":"https://www.leavel.cn/article/20220220.html","excerpt":"Python + Selenium自动化测试练习 实现的功能 1.登录2.将未读信息标记为已读3.将未处理的任务全部通过","text":"Python + Selenium自动化测试练习 实现的功能 1.登录2.将未读信息标记为已读3.将未处理的任务全部通过 main.py 1234567891011121314151617181920212223242526272829from time import sleepfrom selenium.webdriver.common.by import Byimport defaultFunctionimport autoMarkMsgimport autoPassTask# 设置隐性等待时间（最大等待时间10s）defaultFunction.driver.implicitly_wait(10)defaultFunction.driver.get(defaultFunction.url)# 利用Tab键和Enter键实现登录# DefaultFunction.driver.find_element(By.CSS_SELECTOR, '.login-form input[data-v-5f194660]').send_keys(user, Keys.TAB, password, Keys.ENTER)# 利用XPath定位实现登录defaultFunction.driver.find_element(By.XPATH, '//*[@placeholder=\"请输入手机号\"]').send_keys(defaultFunction.user)defaultFunction.driver.find_element(By.XPATH, '//*[@placeholder=\"请输入密码\"]').send_keys(defaultFunction.password)defaultFunction.driver.find_element(By.XPATH, '//*[@type=\"button\"]').click()# 标记未读消息sleep(2)num_str = autoMarkMsg.autoMark(defaultFunction.driver)print(num_str)# # 通过未处理的任务pass_num_task = autoPassTask.passTask(defaultFunction.driver)print(pass_num_task)# 等待10秒后退出浏览器sleep(10)defaultFunction.driver.quit() defaultFunction.py 123456789101112131415161718192021from selenium import webdriverfrom selenium.webdriver.common.by import Byuser = '13280xxxxxxx'password = 'xxxxx'# 开发环境# url = 'http://58.56.xxxxxxxxx/#/login'# 生产环境url = 'http://59.46.xxxxxxxxxx/#/login'driver = webdriver.Chrome()# 定义一个函数判断是否存在某个值def isElementExist(s): \"\"\"\"判断是否存在某个值\"\"\" try: driver.find_element(By.XPATH, s) return True except Exception as e: e return False autoPassTask.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from time import sleep# 需要引入ActionChains类,里面有鼠标调用的方法from selenium.webdriver.common.action_chains import ActionChainsfrom selenium.webdriver.common.by import Byimport defaultFunctiondef passTask(driver): \"\"\"处理未通过的任务\"\"\" # 循环 pass_num_task = '当前无未处理任务' if defaultFunction.isElementExist('//div[2]/div[2]/div[1]/div[3]/table/tbody/tr[1]/td[2]/div'): for m in range(100): # 双击打开消息 element = driver.find_element(By.XPATH, '//div[2]/div[2]/div[1]/div[3]/table/tbody/tr[1]/td[2]/div') # 需要睡眠 sleep(1) ActionChains(driver).double_click(element).perform() sleep(1) # 循环检查打开的流程中是否还存在相关元素 for n in range(3): # 调用判断函数 is_exist = defaultFunction.isElementExist('//form[2]/div[1]/div/label[2]') sleep(1) # 如果存在消息按钮就执行 if is_exist: sleep(1) # 选中通过消息按钮 driver.find_element(By.XPATH, '//form[2]/div[1]/div/label[2]').click() sleep(1) # 点击提交 driver.find_element(By.XPATH, '//div[2]/form[2]/div[3]/div/button[1]/span').click() sleep(1) # 确认提交 driver.find_element(By.XPATH, '//div/div[3]/button[2]/span').click() sleep(1) # 如果已经没有该元素，则提前跳出循环，进入下一步 else: break # 循环的速度很快，如果不加等待时间容易获取不到元素报错 sleep(1) # 循环的速度很快，如果不加等待时间容易获取不到元素报错 sleep(1) # 点击返回按钮 driver.find_element(By.XPATH, '//div[2]/div[1]/button').click() pass_num_task = f'已处理通过&#123;m + 1&#125;条任务' sleep(5) return pass_num_task autoMarkMsg.py 123456789101112131415161718192021222324252627282930313233from time import sleepfrom selenium.webdriver.common.by import Byimport defaultFunctiondef autoMark(driver): \"\"\"标记未读消息函数\"\"\" # 判断如果有未读消息就标记未读消息两条 num_str = '当前无未读消息' if defaultFunction.isElementExist('//div[3]/div[2]/div[1]/div[3]/table/tbody/tr[1]/td[1]/div/label/span/span'): # 循环 for n in range(10000): if defaultFunction.isElementExist( '//div[3]/div[2]/div[1]/div[3]/table/tbody/tr[1]/td[1]/div/label/span/span'): sleep(1) # 选中消息 driver.find_element(By.XPATH, '//div[3]/div[2]/div[1]/div[3]/table/tbody/tr[1]/td[1]/div/label/span/span').click() sleep(1) # 点击已读按钮 driver.find_element(By.XPATH, '//div[2]/div/div[1]/div[3]/div[1]/div/button[1]/span').click() sleep(1) # 确定按钮 driver.find_element(By.XPATH, '//div[3]/div/div[3]/button[2]/span').click() # 循环的速度很快，如果不加等待时间容易获取不到元素报错 sleep(1) else: break num_str = f'已经标为已读&#123;n + 1&#125;条' sleep(5) return num_str","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.leavel.cn/tags/Python/"},{"name":"Selenium","slug":"Selenium","permalink":"https://www.leavel.cn/tags/Selenium/"},{"name":"自动化测试","slug":"自动化测试","permalink":"https://www.leavel.cn/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"}],"keywords":[]},{"title":"随便记记03","slug":"10_Note3","date":"2021-11-09T11:28:14.000Z","updated":"2021-11-09T12:09:22.147Z","comments":true,"path":"article/20211109.html","link":"","permalink":"https://www.leavel.cn/article/20211109.html","excerpt":"Nginx 安装配置 MySQL 安装配置","text":"Nginx 安装配置 MySQL 安装配置 在Linux上安装Tomcat服务器 yum install xxx 安装JDK 安装数据库 运行数据库的脚本 设置权限 将打包好的项目War包放入到Webapps文件夹中 设置文件读写权限 chmod + *.sh 修改数据库配置文件 关闭防火墙 service firewalld stop 启动tomcat服务器","categories":[],"tags":[{"name":"测试环境部署","slug":"测试环境部署","permalink":"https://www.leavel.cn/tags/%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"},{"name":"Linux","slug":"Linux","permalink":"https://www.leavel.cn/tags/Linux/"}],"keywords":[]},{"title":"随便记记02","slug":"9_Note2","date":"2021-06-14T10:37:14.000Z","updated":"2021-11-09T11:27:00.332Z","comments":true,"path":"article/20210614.html","link":"","permalink":"https://www.leavel.cn/article/20210614.html","excerpt":"当打开组合框的下拉列表时发生。 123456private int comboxIndex = -1;private void DropDown(object sender, EventArgs e)&#123; // 获取第一次combobox中的值的索引 comboxIndex = cbValue.SelectedIndex;&#125;","text":"当打开组合框的下拉列表时发生。 123456private int comboxIndex = -1;private void DropDown(object sender, EventArgs e)&#123; // 获取第一次combobox中的值的索引 comboxIndex = cbValue.SelectedIndex;&#125; 12345678910111213141516171819202122232425262728293031323334353637private void ComboBox_SelectionChanged(object sender, EventArgs e)&#123; if(cbValue.Equals(1)) &#123; // 如果选中不符合条件的项目，恢复到默认 ErrorMessageBox.Show(msg); cbValue.SelectedIndex = comboxIndex; &#125;&#125;private readonly string[] _requestColumns = &#123; ColumnNames.A, ColumnNames.B, ColumnNames.C, ColumnNames.D&#125;;var columnValueList = new List&lt;string&gt;();var dataRow = Table.Rows[0];foreach(var requestColumn in _requestColumns)&#123; var columnValue = dataRow[requestColumn].ToString(); if (!string.IsNullOrEmpty(columnValue)) &#123; columnValueList.Add(columnValue); &#125;&#125;foreach (var item in collection)&#123; if (item == \"A\") &#123; // 跳出循环 continue; &#125; if (item == \"B\" ) &#123; // ToDo... &#125;&#125;","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://www.leavel.cn/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"https://www.leavel.cn/tags/WPF/"}],"keywords":[]},{"title":"随便记记01","slug":"2_Note1","date":"2021-04-18T13:45:02.000Z","updated":"2021-11-09T11:26:04.531Z","comments":true,"path":"article/20210418.html","link":"","permalink":"https://www.leavel.cn/article/20210418.html","excerpt":"override 与重载（overload）的区别1.重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要。重载（overload）是面向过程的概念。2.Override 是进行基类中函数的重写。Override 是面向对象的概念","text":"override 与重载（overload）的区别1.重载是方法的名称相同。参数或参数类型不同，进行多次重载以适应不同的需要。重载（overload）是面向过程的概念。2.Override 是进行基类中函数的重写。Override 是面向对象的概念 C#中值类型与引用类型1.值类型：struct、enum、int、float、char、bool、decimal 引用类型：class、delegate、interface、array、object、string C#中类(class)与结构(struct)的异同1.class 可以被实例化,属于引用类型, class 可以实现接口和单继承其他类,还可以作为基类型,是分配在内存的堆上的 struct 属于值类型,不能作为基类型,但是可以实现接口,是分配在内存的栈上的. C#中参数传递 ref 与 out 的区别1.ref 指定的参数在函数调用时必须先初始化，而 out 不用2.out 指定的参数在进入函数时会清空自己，因此必须在函数内部进行初始化赋值操作，而 ref 不用 总结：ref 可以把值传到方法里，也可以把值传到方法外；out 只可以把值传到方法外 注意：string 作为特殊的引用类型，其操作是与值类型看齐的，若要将方法内对形参赋值后的结果传递出来，需要加上 ref 或 out 关键字。 C# 中 static 关键字的作用对类有意义的字段和方法使用 static 关键字修饰，称为静态成员，通过类名加访问操作符“.”进行访问; 对类的实例有意义的字段和方法不加 static 关键字，称为非静态成员或实例成员。 注: 静态字段在内存中只有一个拷贝，非静态字段则是在每个实例对象中拥有一个拷贝。而方法无论是否为静态，在内存中只会有一份拷贝，区别只是通过类名来访问还是通过实例名来访问。 字符串中 string str=null 和 string str=””和 string str=string.Empty 的区别string.Empty 相当于“”,Empty 是一个静态只读的字段。 string str=”” ,初始化对象，并分配一个空字符串的内存空间 string str=null,初始化对象，不会分配内存空间 const 和 readonly 的区别都可以标识一个常量。主要有以下区别： 1、初始化位置不同。const 必须在声明的同时赋值；readonly 即可以在声明处赋值; 2、修饰对象不同。const 即可以修饰类的字段，也可以修饰局部变量；readonly 只能修饰类的字段 3、const 是编译时常量，在编译时确定该值；readonly 是运行时常量，在运行时确定该值。 4、const 默认是静态的；而 readonly 如果设置成静态需要显示声明 5、修饰引用类型时不同，const 只能修饰 string 或值为 null 的其他引用类型；readonly 可以是任何类型。 i++和++i 的区别1.i++是先赋值，然后再自增；++i 是先自增，后赋值。 2.i=0，i++=0，++i=1； Console.WriteLine(++i==i++); 结果位 true C#成员修饰符abstract:指示该方法或属性没有实现。 const:指定域或局部变量的值不能被改动。 event:声明一个事件。 extern:指示方法在外部实现。 override:对由基类继承成员的新实现。 readonly:指示一个域只能在声明时以及相同类的内部被赋值。 static:指示一个成员属于类型本身,而不是属于特定的对象。 virtual:指示一个方法或存取器的实现可以在继承类中被覆盖。 ADO.NET 常用对象Connection：主要是开启程序和数据库之间的连接。没有利用连接对象将数据库打开，是无法从数据库中取得数据的。Close 和 Dispose 的区别，Close 以后还可以 Open，Dispose 以后则不能再用。 Command：主要可以用来对数据库发出一些指令，例如可以对数据库下达查询、新增、修改、删除数据等指令，以及调用存在数据库中的存储过程等。这个对象是架构在 Connection 对象上，也就是 Command： 对象是通过在 Connection 对象连接到数据源。 DataAdapter：主要是在数据源以及 DataSet 之间执行数据传输的工作，它可以透过 Command 对象下达命令后，并将取得的数据放入 DataSet 对象中。这个对象是架构在 Command 对象上，并提供了许多配合 DataSet 使用的功能。 DataSet：这个对象可以视为一个暂存区（Cache），可以把从数据库中所查询到的数据保留起来，甚至可以将整个数据库显示出来，DataSet 是放在内存中的。DataSet 的能力不只是可以储存多个 Table 而已，还可以透过 DataAdapter 对象取得一些例如主键等的数据表结构，并可以记录数据表间的关联。DataSet 对象可以说是http://ADO.NET 中重量级的对象，这个对象架构在 DataAdapter 对象上，本身不具备和数据源沟通的能力；也就是说我们是将 DataAdapter 对象当做 DataSet 对象以及数据源间传输数据的桥梁。DataSet 包含若干 DataTable、DataTableTable 包含若干 DataRow。 DataReader：当我们只需要循序的读取数据而不需要其它操作时，可以使用 DataReader 对象。DataReader 对象只是一次一次向下循序的读取数据源中的数据，这些数据是存在数据库服务器中的，而不是一次性加载到程序的内存中的，只能（通过游标）读取当前行的数据，而且这些数据是只读的，并不允许作其它的操作。因为 DataReader 在读取数据的时候限制了每次只读取一条，而且只能只读，所以使用起来不但节省资源而且效率很好。使用 DataReader 对象除了效率较好之外，因为不用把数据全部传回，故可以降低网络的负载。 数字格式化转换可使用“0”和“#”占位符进行补位。“0” 表示位数不够位数就补充“0”，小数部分如果位数多了则会四舍五入；“#”表示占位，用于辅助“0”进行补位。如下例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// “0”描述：占位符，如果可能，填充位 Console.WriteLine(string.Format(\"&#123;0:000000&#125;\", 1234)); // 结果：001234// “#”描述：占位符，如果可能，填充位Console.WriteLine(string.Format(\"&#123;0:######&#125;\", 1234)); // 结果：1234Console.WriteLine(string.Format(\"&#123;0:#0####&#125;\", 1234)); // 结果：01234Console.WriteLine(string.Format(\"&#123;0:0#0####&#125;\", 1234)); // 结果：0001234// \".\"描述：小数点Console.WriteLine(string.Format(\"&#123;0:000.000&#125;\", 1234)); // 结果：1234.000Console.WriteLine(string.Format(\"&#123;0:000.000&#125;\", 4321.12543)); // 结果：4321.125​// \",\"描述：千分表示Console.WriteLine(string.Format(\"&#123;0:0,0&#125;\", 1234567)); //结果：1,234,567​// \"%\"描述：格式化为百分数Console.WriteLine(string.Format(\"&#123;0:0%&#125;\", 1234)); // 结果：123400%Console.WriteLine(string.Format(\"&#123;0:#%&#125;\", 1234.125)); // 结果：123413%Console.WriteLine(string.Format(\"&#123;0:0.00%&#125;\", 1234)); // 结果：123400.00%Console.WriteLine(string.Format(\"&#123;0:#.00%&#125;\", 1234.125)); // 结果：123412.50%内置快捷字母格式化用法// E-科学计数法表示Console.WriteLine((25000).ToString(\"E\")); // 结果：2.500000E+004// C-货币表示，带有逗号分隔符，默认小数点后保留两位，四舍五入Console.WriteLine((2.5).ToString(\"C\")); // 结果：￥2.50​// D[length]-十进制数Console.WriteLine((25).ToString(\"D5\")); // 结果：00025​// F[precision]-浮点数，保留小数位数(四舍五入)Console.WriteLine((25).ToString(\"F2\")); // 结果：25.00​// G[digits]-常规，保留指定位数的有效数字，四舍五入Console.WriteLine((2.52).ToString(\"G2\")); // 结果：2.5​// N-带有逗号分隔符，默认小数点后保留两位，四舍五入Console.WriteLine((2500000).ToString(\"N\")); // 结果：2,500,000.00​// X-十六进制，非整型将产生格式异常Console.WriteLine((255).ToString(\"X\")); // 结果ToString 也可以自定义补零格式化：​Console.WriteLine((15).ToString(\"000\")); // 结果：015Console.WriteLine((15).ToString(\"value is 0\")); // 结果：value is 15Console.WriteLine((10.456).ToString(\"0.00\")); // 结果：10.46Console.WriteLine((10.456).ToString(\"00\")); // 结果：10Console.WriteLine((10.456).ToString(\"value is 0.0\")); // 结果：value is 10.5 字符串拼接、字符串内插法将数组中的字符串拼接成一个字符串： 123var parts = new[] &#123; \"Foo\", \"Bar\", \"Fizz\", \"Buzz\"&#125;;var joined = string.Join(\", \", parts);// joined = \"Foo, Bar, Fizz, Buzz\" 以下四种方式都可以达到相同的字符串拼接的目的： 123456string first = \"Hello\";stringsecond = \"World\";string foo = first + \" \" + second;string foo = string.Concat(first, \" \", second);string foo = string.Format(\"&#123;0&#125; &#123;1&#125;\", firstname, lastname);string foo = $\"&#123;firstname&#125; &#123;lastname&#125;\"; 字符串内插法简单用法： 123var name = \"World\";var str =$\"Hello, &#123;name&#125;!\";// str = \"Hello, World!\" 带日期格式化 12var date = DateTime.Now;var str = $\"Today is &#123;date:yyyy-MM-dd&#125;！\"; 补齐格式化（Padding）： 1234567var number = 42;// 向左补齐var str = $\"The answer to life, the universe and everything is &#123;number,5&#125;.\";// str = \"The answer to life, the universe and everything is ___42.\" ('_'表示空格)// 向右补齐var str = $\"The answer to life, the universe and everything is $&#123;number,-5&#125;.\";// str = \"The answer to life, the universe and everything is 42___.\" 结合内置快捷字母格式化： 123456var amount = 2.5;var str = $\"It costs &#123;amount:C&#125;\";// str = \"￥2.50\"var number = 42;var str = $\"The answer to life, the universe and everything is &#123;number,5:f1&#125;.\";// str = \"The answer to life, the universe and everything is ___42.1\"","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://www.leavel.cn/tags/C/"}],"keywords":[]},{"title":"C# Path.Combine方法代码示例","slug":"3_Combine","date":"2021-01-28T13:41:35.000Z","updated":"2021-04-25T12:52:51.988Z","comments":true,"path":"article/20210128.html","link":"","permalink":"https://www.leavel.cn/article/20210128.html","excerpt":"C# Path.Combine12345678910111213141516171819202122string s1 = Path.Combine(\"D:\", \"file.txt\"); // D:file.txtstring s2 = Path.Combine(\"D:\\\\\", \"file.txt\"); // D:\\file.txtstring s3 = Path.Combine(\"D:\\\\dir\", \"file.txt\"); // D:\\dir\\file.txtstring s4 = Path.Combine(\"D:\\\\dir\\\\\", \"file.txt\"); // D:\\dir\\file.txtstring s5 = Path.Combine(\"D:\", \"/file.txt\"); // /file.txtstring s6 = Path.Combine(\"D:\\\\\", \"\\\\file.txt\"); // \\file.txtstring s7 = Path.Combine(\"D:\\\\dir\\\\\", \"/file.txt\"); // /file.txtstring s8 = Path.Combine(\"D:\\\\dir\\\\\", \"\\\\file.txt\"); // \\file.txtvar fileDir = \"C:\\\\Windows\";var fileDir2 = \"C:\\Windows\"; //编译器直接报错var fileName = \"file.txt\";var filePath1= Path.Combine(@\"C:\\Windows\", fileName);// sendDir、fileName不能为空var filePath2 = Path.Combine(fileDir, fileName);if (File.Exists(filePath1))&#123; File.Delete(filePath);&#125;","text":"C# Path.Combine12345678910111213141516171819202122string s1 = Path.Combine(\"D:\", \"file.txt\"); // D:file.txtstring s2 = Path.Combine(\"D:\\\\\", \"file.txt\"); // D:\\file.txtstring s3 = Path.Combine(\"D:\\\\dir\", \"file.txt\"); // D:\\dir\\file.txtstring s4 = Path.Combine(\"D:\\\\dir\\\\\", \"file.txt\"); // D:\\dir\\file.txtstring s5 = Path.Combine(\"D:\", \"/file.txt\"); // /file.txtstring s6 = Path.Combine(\"D:\\\\\", \"\\\\file.txt\"); // \\file.txtstring s7 = Path.Combine(\"D:\\\\dir\\\\\", \"/file.txt\"); // /file.txtstring s8 = Path.Combine(\"D:\\\\dir\\\\\", \"\\\\file.txt\"); // \\file.txtvar fileDir = \"C:\\\\Windows\";var fileDir2 = \"C:\\Windows\"; //编译器直接报错var fileName = \"file.txt\";var filePath1= Path.Combine(@\"C:\\Windows\", fileName);// sendDir、fileName不能为空var filePath2 = Path.Combine(fileDir, fileName);if (File.Exists(filePath1))&#123; File.Delete(filePath);&#125;","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://www.leavel.cn/tags/C/"}],"keywords":[]},{"title":"C#常用的排序方法","slug":"1_Sort","date":"2020-11-08T02:04:53.000Z","updated":"2021-04-25T12:27:17.254Z","comments":true,"path":"article/20201108.html","link":"","permalink":"https://www.leavel.cn/article/20201108.html","excerpt":"冒泡排序(Bubble Sort)基本思路是：将相邻的记录的关键码进行比较，若前面记录的关键码大于后面记录的关键码，则将它们交换，否则不交换。","text":"冒泡排序(Bubble Sort)基本思路是：将相邻的记录的关键码进行比较，若前面记录的关键码大于后面记录的关键码，则将它们交换，否则不交换。 12345678910111213141516static void Sort(int[] arrNum)//传递一个数组排序&#123; //冒泡排序 for (int i = 0; i &lt; arrNum.Length-1; i++) &#123; for (int j = 0; j &lt; arrNum.Length-1-i; j++) &#123; if (arrNum[j]&gt;arrNum[j+1]) &#123; int temp = arrNum[j]; arrNum[j] = arrNum[j+1]; arrNum[j+1] = temp; &#125; &#125; &#125; &#125; 123456789101112131415161718static void Sort(int[] sortArray)//传递一个数组排序&#123; bool swapped; do &#123; swapped = false;//如果不发生交换，do-while则跳出循环 for (int i = 0; i &lt; sortArray.Length - 1; i++) &#123; if (sortArray[i] &gt; sortArray[i + 1]) &#123; int temp = sortArray[i]; sortArray[i] = sortArray[i + 1]; sortArray[i + 1] = temp; swapped = true;//如果发生交换，do-while则继续循环 &#125; &#125; &#125; while (swapped);&#125; 简单选择排序(Simple Select Sort)算法基本思路是：从左到右开始,以第一个元素 (i = 0) 作为 基准数,与后面的数作比较,找到比它小的数就置换位置,以此类推 ,以第二元素(i = 1) 作为 基准数,与后面的数比较,找到比它小的数就置换位置.直至循环结束. 123456789101112131415161718192021222324252627282930static void InsertSort(int[] dataArray)&#123; for (int i = 1; i &lt; dataArray.Length; i++) &#123; int iValue = dataArray[i]; bool isInsert = false; //拿到i位置的元素 跟前面所有的元素作比较 for (int j = i - 1; j &gt;= 0; j--) &#123; if (dataArray[j] &gt; iValue) &#123; //如果发现比i大的,就让它向后移动 dataArray[j + 1] = dataArray[j]; &#125; else &#123; //发现一个比i小的值就停下来 dataArray[j + 1] = iValue; isInsert = true; break; &#125; &#125; //如果i这个值最小,所有元素都向后移动一位了,就把这个元素放到 0 号索引上 if (isInsert == false) &#123; dataArray[0] = iValue; Console.WriteLine(iValue); &#125; &#125;&#125; 快速排序该方法的基本思想是：1．先从数列中取出一个数作为基准数。2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。3．再对左右区间重复第二步，直到各区间只有一个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445static void QuickSort(int[] dataArray, int left, int right)&#123; if (left &lt; right) &#123; //基准数， 把比它小或者等于它的 放在它的左边，然后把比它大的放在它的右边 int x = dataArray[left]; int i = left; int j = right; while (i &lt; j)//当i==j的时候，说明我们找到了一个中间位置，这个中间位置就是基准数应该所在的位置 &#123; //从后往前比较 //找到了一个比基准数 小于或者等于的数子，应该把它放在x的左边 while (i &lt; j) &#123; if (dataArray[j] &lt;= x) &#123; dataArray[i] = dataArray[j]; break; &#125; else &#123; j--;//向左移动 到下一个数字，然后做比较 &#125; &#125; //从前往后 while (i &lt; j) &#123; if (dataArray[i] &gt; x) &#123; dataArray[j] = dataArray[i]; break; &#125; else &#123; i++; &#125; &#125; &#125; //跳出循环 现在i==j i是中间位置 dataArray[i] = x; QuickSort(dataArray, left, i - 1);// left -i- right QuickSort(dataArray, i + 1, right); &#125;&#125; Array.Sort()From：https://docs.microsoft.com/en-US/dotnet/api/system.array.sort?view=netcore-3.1 转载于：https://blog.csdn.net/qq_40985921/article/details/90727368","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://www.leavel.cn/tags/C/"},{"name":"排序","slug":"排序","permalink":"https://www.leavel.cn/tags/%E6%8E%92%E5%BA%8F/"}],"keywords":[]},{"title":"利用Hexo创建博客","slug":"7_Hexo","date":"2020-11-07T05:34:53.000Z","updated":"2021-04-25T12:48:59.296Z","comments":true,"path":"article/20201107.html","link":"","permalink":"https://www.leavel.cn/article/20201107.html","excerpt":"1. 创建GitHub仓库仓库名必须为 xxxxx.github.io 格式;","text":"1. 创建GitHub仓库仓库名必须为 xxxxx.github.io 格式; 2. 全局安装hexo1234// 安装npm install hexo -g// 查看版本hexo -v 3. 初始化项目1234// 初始化hexo init// 本地运行hexo s 4. 部署到github找到 _congif.yml，找到 deploy 字段并填写 1234deploy: type: git repository: https://github.com/liiiuyang/liiiuyang.github.io.git branch: master 修改完毕后 安装deployer工具 1npm install hexo-deployer-git --save 完成后再执行下面命令 推送到github仓库 123hexo cleanhexo ghexo d 之后输入网址liiiuyang.github.io就可以看到效果了 5. 新建文章1hexo new \"Test\" #新建文章 在你的本地路径\\source_posts\\下会生成Test.md文件。用Markdown语法写下你的文章保存后执行如下指令： 123hexo cleanhexo ghexo d 文章发布成功！ 6. 将GitHub网址改成自己的域名本地仓库\\source下新建一个CNAME(没有扩展名)文件填入内容： 12// 自己的域名https://www.lihua.cool 将该文件推送到GitHub仓库","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.leavel.cn/tags/Hexo/"}],"keywords":[]},{"title":"C#获取ListBox里的数据","slug":"4_Listbox","date":"2020-08-23T02:49:00.000Z","updated":"2021-04-25T12:47:12.673Z","comments":true,"path":"article/20200823.html","link":"","permalink":"https://www.leavel.cn/article/20200823.html","excerpt":"C#获取ListBox里的数据 1234567891011121314public List&lt;string&gt; SelectedFileNames&#123; get &#123; List&lt;string&gt; temp = new List&lt;string&gt;(); foreach (var item in listBox.SelectedItems) &#123; temp.Add(item.ToString()); &#125; //排序 temp.Sort() return temp; &#125;&#125;","text":"C#获取ListBox里的数据 1234567891011121314public List&lt;string&gt; SelectedFileNames&#123; get &#123; List&lt;string&gt; temp = new List&lt;string&gt;(); foreach (var item in listBox.SelectedItems) &#123; temp.Add(item.ToString()); &#125; //排序 temp.Sort() return temp; &#125;&#125; DataTable的操作123456789101112131415161718192021222324252627string stuName = \"\";// Xstring stuName = string.Empty;// √stuName.Equals(\"Tom\");// √string.IsNullOrEmpty(stuName);// √// 过滤 DataTable 中的数据var filter = string.Format(\"ID = &#123;0&#125; AND STUNAME &lt;&gt; '&#123;1&#125;' AND AGE = &#123;2&#125; AND SEX IS NOT NULL\", id, stuName, 12);var stuRow = stuTable.Select(filter);// 存在数据if (stuRow.Length &gt; 0)&#123; // 克隆表结构 var itemStuTable = stuTable.Clone(); // 遍历过滤出的数据 foreach(DataRow row in stuRow ) &#123; // 添加数据到新表中 itemStuTable.ImportRow(row); &#125; &#125;&#125;// 如果SchoolObject这个DataSet不存在这个表if(!SchoolObject.Tables.Contains(TableNames.stuTable))&#123;//&#125; 调用Command，获取userid12345var getUserNameCommand = new GetUserNameCommand();getUserNameCommand.SetUser(userid);var result = Context.Current.ExecuteUICommand(getUserNameCommand);var userTable = result.Value.Tables[0];string userid = userTable.Rows[0][ColumnNames.USERID].ToString(); Command内容12345678public class GetUserNameCommand : ApiCommand&#123;private const string NAME = \"GetUserName\";public GetUserNameCommand() : base(NAME) &#123; Component = CommonAPI; &#125; 12345678/// &lt;summary&gt;/// 取得したいユーザIDを設定/// &lt;/summary&gt;/// &lt;param name=\"userid\"&gt;ユーザID/param&gt;public void SetUser(string userid)&#123; ArgumentUtil.SetValue(Argument, ColumnNames.USERID, userid);&#125; 遍历123foreach (DataRow rows in tstList.Rows)foreach (DataRowView rowView in ttstRows)foreach (var row in e.Rows.Select(rowView =&gt; rowView.Row)) 123456789101112131415dat0 = GetInf(data01, data02, data03, data04, false);/// &lt;/summary&gt;/// &lt;param name=\"data01\"&gt;&lt;/param&gt;/// &lt;param name=\"data02\"&gt;&lt;/param&gt;/// &lt;param name=\"data03\"&gt;&lt;/param&gt;/// &lt;param name=\"data04\"&gt;&lt;/param&gt;/// &lt;param name=\"multiFlag\"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static string GetInf(string data01, string data02, string data03, string data04, bool multiFlag)private static List&lt;decimal&gt; GetUserInf(ListEventArgs e)private static DataTable GetUserInf(IList&lt;DataRowView&gt; ttstRows)private static string GetUserInf(string data01, string data02, string data03, string data04)","categories":[],"tags":[{"name":"C#","slug":"C","permalink":"https://www.leavel.cn/tags/C/"},{"name":"WPF","slug":"WPF","permalink":"https://www.leavel.cn/tags/WPF/"}],"keywords":[]},{"title":"自动化测试","slug":"8_Test","date":"2020-08-05T10:37:14.000Z","updated":"2021-04-24T07:59:43.516Z","comments":true,"path":"article/20200805.html","link":"","permalink":"https://www.leavel.cn/article/20200805.html","excerpt":"自动化测试open 打开网址 Targetclick 点击 Target(id=kw ) （定位要点击的ID）type 输入内容 Target (id=kw ) Value (要输入的内容)click Target（id=su）refresh 刷新 没有参数goBack 返回pause 暂停 Target(5000)单位为毫秒windowMaximize 窗口最大化select模拟人工单击下拉列表框 value(里面填定位到的值) label(里面填真实的值)例：select Target name=CookieDate Value label=留一天 clickAndWait（单击事件导致新的页面进行加载） css=input.lobtnclose 关闭","text":"自动化测试open 打开网址 Targetclick 点击 Target(id=kw ) （定位要点击的ID）type 输入内容 Target (id=kw ) Value (要输入的内容)click Target（id=su）refresh 刷新 没有参数goBack 返回pause 暂停 Target(5000)单位为毫秒windowMaximize 窗口最大化select模拟人工单击下拉列表框 value(里面填定位到的值) label(里面填真实的值)例：select Target name=CookieDate Value label=留一天 clickAndWait（单击事件导致新的页面进行加载） css=input.lobtnclose 关闭 断言四种模式 Assert 失败时，该测试终止 verify 失败时，测试继续进行，将错误记入 waitfor用于等待某些条件为变为真。可用于AJAX应用程序的测试，如果该条件为真，他们将立即成功执行，不为真时，则失败，暂停测试，直至超过当前所设定的超时时间，一般与timeout一起用 store定义变量，可以获取页面相关的元素进行判断五种手段 Title获取页面标题 Value获取元素的值 Text获取元素文本信息 Table获得元素标签 ElementPresent获得当前元素 断言常用的有（需要设置的断言鼠标右键–Show All Available Commands）Command Target ValueassertTitle 百度一下(验证标题是不是百度一下，如果不是，终止)verifyTitle 百度一下(验证标题是不是百度一下，如果不是，继续执行) python基础 转义字符 print(“C:HYPERLINK “\\\\python37”\\python37”)双斜杠意思为在C盘下的python37文件夹 12my name is &#39;Jack&#39; and &quot;you&quot;print(&quot;my name is \\&#39;Jack\\&#39; and \\&quot;you\\&quot;&quot;) 通过“\\”转义出原来的字符 数组定义 12student&#x3D;[&#39;Jack&#39;,&#39;Rose&#39;,&#39;Ben&#39;,&#39;Ella&#39;]print(student) 访问数组元素print(student[0]) -1访问最后一个元素print(student[-1]) 数组元素的添加与修改 末尾追加元素 12student&#x3D;[&quot;jack&quot;,&quot;rose&quot;,&quot;ann&quot;,&quot;ben&quot;]student.append(&#39;mike&#39;) 指定位置添加元素student.insert(0,&quot;hello&quot;) 修改元素`student[1]=”Jack” 删除末尾元素student.pop() 删除指定元素(第四个) 12student.pop(3)print(student) 元组（Tuple） 元组与数组类似，不同之处在于元组的元素一旦定义就不能修改。数组使用【】，元组使用（）。 123456course&#x3D;(&quot;Chinese&quot;,&quot;Math&quot;,&quot;English&quot;,&quot;History&quot;)print(course)print(course[0])print(course[1:3])print(course[1:]) &#x2F;&#x2F;显示索引1之后全部元素print(course[:2]) 元组的个数print(len(course)) 要定义只有一个元素的元组需要在元素后面加一个逗号，用来消除数学歧义 12t&#x3D;(1,)print(t) 返回元组最大值 12score&#x3D;(78,59,86,95,100)print(max(score)) 字典（Dictionary） 字典是另一种可变容器模型，而且可以存储任意类型对象。字典的每一个键值（key=&gt;value）对用冒号（:）分割，每个对之间用逗号(,)分割，整个字典包括在花括号｛｝中d={key1 :value1,key2 :value2,key3 :value3}键必须是唯一的，但值则不必。值可以取任何数据类型，但键必须是不可变的。 定义访问字典12student&#x3D;&#123;1:&quot;Jack&quot;,2:&quot;Mike&quot;,3:&quot;Mike&quot;,4:&quot;Anna&quot;&#125;print(student[2]) 添加元素12student[5]&#x3D;&quot;Rose&quot;print(student) 修改元素12student[2]&#x3D;&quot;Marry&quot;print(student) 删除字典12del student[1]student.clear() del studentprint(student)","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://www.leavel.cn/tags/Python/"},{"name":"测试","slug":"测试","permalink":"https://www.leavel.cn/tags/%E6%B5%8B%E8%AF%95/"}],"keywords":[]},{"title":"Oracle数据库导入备份","slug":"6_Oracle","date":"2020-07-24T01:11:05.000Z","updated":"2021-04-25T12:49:24.580Z","comments":true,"path":"article/20200724.html","link":"","permalink":"https://www.leavel.cn/article/20200724.html","excerpt":"Oracle数据库导入备份 以sys用户登录名为Test01 的数据库sqlplus sys/sys@Test01 as sysdba;","text":"Oracle数据库导入备份 以sys用户登录名为Test01 的数据库sqlplus sys/sys@Test01 as sysdba; 删除其中的用户drop user leo cascade; 创建用户CREATE USER &quot;LEO&quot; PROFILE &quot;DEFAULT&quot; IDENTIFIED BY &quot;leo&quot; DEFAULT TABLESPACE &quot;USERS&quot; TEMPORARY TABLESPACE &quot;TEMP&quot; ACCOUNT UNLOCK; 连接权限给用户GRANT &quot;CONNECT&quot; TO &quot;LEO&quot;; 授予管理员权限GRANT &quot;DBA&quot; TO &quot;LEO&quot; 退出exit; 导入数据库备份文件impdp leo/leo@Test01 directory=dump_dir dumpfile=ORACLEDATE2020.DMP schemas=leo dump_dir为备份文件存放路径 ORACLEDATE2020.DMP为备份文件名","categories":[],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"https://www.leavel.cn/tags/Oracle/"}],"keywords":[]},{"title":"Markdown语法","slug":"5_Markdown","date":"2020-07-23T05:07:06.000Z","updated":"2021-04-25T12:47:51.409Z","comments":true,"path":"article/20200723.html","link":"","permalink":"https://www.leavel.cn/article/20200723.html","excerpt":"字体要加粗的文字左右分别用两个星号包起来要倾斜的文字左右分别用一个星号包起来要倾斜和加粗的文字左右分别用三个星号包起来要加删除线的文字左右分别用两个波浪号~包起来","text":"字体要加粗的文字左右分别用两个星号包起来要倾斜的文字左右分别用一个星号包起来要倾斜和加粗的文字左右分别用三个星号包起来要加删除线的文字左右分别用两个波浪号~包起来 标题一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。注：标准语法一般在#后跟个空格再写文字 引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; 分割线三个或者三个以上的 - 或者 * 都可以。 图片1![](https:&#x2F;&#x2F;i.niupic.com&#x2F;images&#x2F;2020&#x2F;07&#x2F;23&#x2F;8rLL.jpg) 超链接1[超链接名](超链接地址 &quot;超链接title&quot;) 简书百度Github 列表无序列表用 - + * 任何一种都可以 列表内容 列表内容 列表内容 有序列表 数字加点(序号跟内容之间要有空格) 列表内容 列表内容 列表内容 代码前后用一个(反引号)包住Range(“姓名”).Offset(ofs, 0) = name前后用三个(反引号)包住 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun();","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://www.leavel.cn/tags/Markdown/"}],"keywords":[]},{"title":"Hello World","slug":"0_HelloWorld","date":"2020-07-22T06:13:34.000Z","updated":"2021-04-25T12:32:16.272Z","comments":true,"path":"article/20200722.html","link":"","permalink":"https://www.leavel.cn/article/20200722.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.leavel.cn/tags/Hexo/"}],"keywords":[]}]}